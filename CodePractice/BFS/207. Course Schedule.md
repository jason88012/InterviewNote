# [207. Course Schedule](https://leetcode.com/problems/course-schedule/)

## 題目大綱
其實就是找出有向圖中是否有"環"的存在，題目給的輸入是一連串的edge，每個edge由兩個節點組成，第一個節點depends on第二個節點
Ex.
`input = [[0, 1]]`，代表要到節點0之前必須先經過節點1。
Ex.
`input = [[0, 1], [1, 0]]`，代表到節點0之前必須先經過節點1，到節點1之前必須先經過節點0，這就是一個環形。

## 解法 BFS + Topology sort
找出有向圖中是否有環可以透過topology sort來達成，這個方法可以用DFS也可以用BFS，但為了練習BFS，所以這邊使用BFS來解。

先來講解topology sort + BFS的概念是甚麼:
參考[這篇教材](https://www.csie.ntu.edu.tw/~sprout/algo2017/ppt_pdf/topological_sort.pdf)的BFS變形版本
其中所謂的**入度(in-degree)**代表要進入這個節點前，必須要先進幾個前面的節點，**出度(out-degree)**代表進了這個節點後，可以往幾個節點走。
在這個算法中，我們不斷檢查每個節點入度是否為0，是的話代表這個節點已經可以走了，就把這個節點push進一個queue裡，然後把該節點連接的所有節點的入度減1，如此重複直到所有節點的入度都是0。

為了計算所有節點的in-degree，先把題目給的edges轉換成adjacency list。方法如下所示:

```cpp
/**
 * 假設其中一個edge長這樣: [0, 1]
 * 這代表要到0之前必須先經過1，圖會長這樣: 0 <- 1
 * 所以我們的adjacency list中，adj_list[1] = {0}，代表到0之前必須先經過1
 */
vector<vector<int>> buildAdjacencyList(int numCourses, vector<vector<int>>& prerequisites){
    vector<vector<int>> adj_list(numCourses);
    for (auto edge: prerequisites){
        adj_list[edge[1]].push_back[edge[0]];
    }
    return adj_list;
}
```

再來我們得利用adjacency list來計算每個節點的in-degree，方法如下:

```cpp
/**
 * 假設在adj_list中長這樣: adj_list[2] = {0, 1, 3}
 * 這代表經過2之後，可能可以繼續往0, 1, 3前進，同時這也代表0, 1, 3這三個節點至少有一個in-degree是2
 * 所以在每個adj_list中出現的節點，代表這個節點的in-degree
 */
vector<int> calcInDegree(vector<vector<int>>& adj_list){
    vector<int> degrees(adj_list.size(), 0);    // 一開始所有節點in-degree都設為0
    for (int i = 0; i < adj_list.size(); ++i){
        for (int node: adj_list[i]){
            degrees[i]++;
        }
    }
    return degrees;
}
```

接下來我們就可以套用演算法中的BFS了

```cpp
bool canFinish(int numCourse, vector<vector<int>>& prerequisites){
    vector<vector<int>> adj_list = buildAdjacencyList(numCourse, prerequisites);
    vector<int> in_degrees = calcInDegree(adj_list);

    for (int i = 0; i < numCourse; ++i){
        int j = 0;      // j 寫外面是因為後面會用到，這邊也可以用while
        for (; j < numCourse; ++j){
            // 當一個節點的in-degree為0，代表該節點前面的節點都被走過，我們可以接著走這個節點了。
            // 一般來說會把它push進一個queue，但這邊我們要直接用這個值，所以不必浪費空間
            if (in_degrees[j] == 0) break;
        }

        // 若上面那層迴圈沒有找到in-degree為0的節點，代表無法做完topology sort
        // 這也代表途中有環，直接return false.
        if (j == numCourse) return false;

        // 把in-degree = 0的節點，in-degree設為 < 0的一個數字，避免被再次找到
        in_degrees[j] = -1;

        // 把in-degree = 0的節點所有out節點的in-degree - 1，代表這些節點的
        // 前一個節點已經被走過了
        for (int node: adj_list[j]){
            in_degrees[node]--;
        }
    }
    // 成功走完所有節點，代表是一個DAG
    return true;
}

```