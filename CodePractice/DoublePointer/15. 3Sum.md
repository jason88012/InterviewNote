# [15. 3Sum](https://leetcode.com/problems/3sum/)

## 題目大綱
給一個未排序int array，找出**所有**挑出三個數總合為0的組合，有限制組合不可重複。

## 想法1: Backtracking
這題關鍵字十分明顯: **所有組合**，我們馬上可以想到使用backtracking來解，實際上也的確解得出來，但卻沒辦法同時考慮另一個條件: 不能重複，所以一樣要用`std::set`先存backtracking找到的結果，最後再轉回`std::vector`。

## 想法2: Double Pointer
另一個想法是: 先對array排序，然後使用一個for迴圈裏面再包一個double pointer，在檢查每個組合的過程中去檢查每個值是否跟上一個檢查的一樣，如此就能避免重複出現的問題。這題Double Pointer的概念也很簡單，如果總和比0小，代表要再加大，所以l要往右移動，反之要變小，r要往左移動。

```cpp
vector<vector<int>> ThreeSum(vector<int>& nums){
		vector<vector<int>> result = {};
		if (nums.size() < 3) return result;

		sort(nums.begin(), nums.end());

		for (int i = 0; i < nums.size() - 2; ++i) {
			if (i > 0 && nums[i] == nums[i - 1]) continue;
			int l = i + 1, r = nums.size() - 1;
			while (l < r) {
				int sum = nums[i] + nums[l] + nums[r];
				if (sum == 0) {
					result.push_back({ nums[i], nums[l], nums[r] });
				}
				if (sum <= 0) {
					int current_l = nums[l];
                    // 這邊要注意 l 與 r 的邊界條件，如果沒先檢查就++取值比大小，會overflow
					while (l < nums.size() && nums[l] == current_l) l++;
				}
				else {
					int current_r = nums[r];
                    // 這邊要注意 l 與 r 的邊界條件，如果沒先檢查就--取值比大小，會overflow
					while (r > i && nums[r] == current_r) r--;
				}
			}
		}
		return result;
}
```